<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sort Visualizer</title>
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #2d2d2d;
            --bar-color: #4db8ff;
            --text-color: #f0f0f0;
            --container-height: 450px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding-bottom: 50px;
        }

        h1 { margin-top: 20px; font-size: 2rem; text-shadow: 2px 2px 4px #000; }

        /* Panel điều khiển */
        .control-panel {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            width: 95%;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6);
            z-index: 10;
        }

        .group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 8px 15px;
            border: 1px solid #555;
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
        }

        input[type="text"] {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #666;
            background: #333;
            color: white;
            font-size: 0.9rem;
            width: 150px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ccc;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        input[type=range] { cursor: pointer; width: 100px; }

        select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #666;
            background: #333;
            color: #ffd700;
            font-weight: bold;
            cursor: pointer;
        }

        button {
            padding: 10px 18px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        /* Màu nút */
        .btn-algo { background-color: #007bff; }
        .btn-algo:hover { background-color: #0056b3; transform: translateY(-2px); }
        .btn-control { background-color: #28a745; min-width: 90px; }
        .btn-control:hover { background-color: #1e7e34; transform: translateY(-2px); }
        .btn-reset { background-color: #dc3545; min-width: 90px; }
        .btn-reset:hover { background-color: #a71d2a; transform: translateY(-2px); }
        .btn-step { background-color: #ffc107; color: #222; }
        .btn-step:hover { background-color: #e0a800; transform: translateY(-2px); }
        .btn-input { background-color: #6c757d; }
        .btn-input:hover { background-color: #5a6268; }

        button:disabled, select:disabled, input[type=range]:disabled { 
            background-color: #444 !important; 
            cursor: not-allowed; opacity: 0.5; transform: none; box-shadow: none; color: #aaa; border-color: #444;
        }

        #status-board {
            font-size: 1.4rem; color: #ffd700; font-weight: bold; height: 30px; margin: 5px 0 10px 0; text-align: center;
        }

        /* --- MAIN DISPLAY LAYOUT --- */
        #main-display {
            display: flex;
            flex-direction: row; /* Mặc định là hàng ngang */
            width: 98%;
            gap: 10px;
            align-items: flex-start;
            justify-content: center;
            transition: all 0.3s ease;
        }

        /* Chế độ xem Bar */
        .mode-bar #visualizer-container { width: 100%; display: flex; }
        .mode-bar #tree-view { display: none; }

        /* Chế độ xem Tree */
        .mode-tree #visualizer-container { display: none; }
        .mode-tree #tree-view { width: 100%; display: flex; }

        /* Chế độ xem Both (50-50) */
        .mode-both #visualizer-container { width: 50%; display: flex; }
        .mode-both #tree-view { width: 50%; display: flex; }

        /* KHUNG BAR CHART */
        #visualizer-container {
            align-items: flex-end;
            justify-content: center;
            height: var(--container-height);
            background-color: #252525;
            border-bottom: 5px solid #777;
            padding: 60px 10px 60px 10px;
            overflow-x: auto;
            border-radius: 8px;
            box-sizing: border-box;
            transition: width 0.3s;
        }

        .bar-wrapper {
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center; margin: 0 4px; position: relative; min-width: 30px; flex-shrink: 0;
        }
        .bar {
            width: 30px; background-color: var(--bar-color); border-top-left-radius: 6px; border-top-right-radius: 6px; transition: height 0.2s ease, background-color 0.2s; position: relative; box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .bar-val {
            margin-bottom: 8px; font-size: 14px; color: #fff; font-weight: bold; text-shadow: 1px 1px 2px black; z-index: 2;
        }
        
        .delete-icon {
            margin-top: 10px; width: 20px; height: 20px; border-radius: 50%; background-color: #444; color: #ff6b6b; font-size: 14px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s, transform 0.2s; user-select: none;
        }
        .bar-wrapper:hover .delete-icon { opacity: 1; transform: scale(1.1); }
        .delete-icon:hover { background-color: #fff; color: red; }
        body.running .delete-icon { display: none !important; }

        .indicator-container {
            position: absolute; bottom: -50px; display: flex; flex-direction: column; align-items: center; width: 100%; pointer-events: none;
        }
        .arrow-label {
            font-size: 12px; font-weight: bold; padding: 3px 6px; border-radius: 4px; margin-top: 3px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* KHUNG TREE VIEW (SVG) */
        #tree-view {
            height: var(--container-height); /* Cùng chiều cao với Bar */
            background-color: #252525;
            border-radius: 8px;
            justify-content: center;
            overflow: auto;
            border: 2px solid #555;
            position: relative;
            box-sizing: border-box;
            transition: width 0.3s;
            display: none; /* Ẩn mặc định */
        }
        #tree-svg { width: 100%; height: 100%; min-width: 600px; }
        
        /* Node trên cây */
        .tree-node circle { fill: #4db8ff; stroke: #fff; stroke-width: 2px; transition: fill 0.2s; }
        .tree-node text { fill: white; font-weight: bold; font-size: 14px; text-anchor: middle; dominant-baseline: middle; }
        .tree-line { stroke: #666; stroke-width: 2px; }
        
        /* Mũi tên trên cây */
        .tree-arrow-compare { stroke: #ffa502; stroke-width: 3px; fill: none; marker-end: url(#arrowhead-compare); stroke-dasharray: 5,5; }
        .tree-arrow-swap { stroke: #ff4757; stroke-width: 3px; fill: none; marker-end: url(#arrowhead-swap); }

        /* KHUNG LOG TABLE */
        #log-container {
            width: 98%;
            max-height: 200px;
            overflow-y: auto;
            background-color: #252525;
            border-radius: 8px;
            border: 1px solid #555;
            padding: 10px;
            box-sizing: border-box;
            margin-top: 20px;
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; color: #ddd; }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #444; }
        th { background-color: #333; color: #ffd700; position: sticky; top: 0; }
        tr:nth-child(even) { background-color: #2a2a2a; }
        tr:hover { background-color: #383838; }
        .log-step { color: #28a745; font-weight: bold; width: 15%; }
        .log-array { font-family: 'Consolas', monospace; color: #4db8ff; }

        /* Colors */
        .idx-i { background-color: #ff4757; color: white; }
        .idx-j { background-color: #2ed573; color: white; }
        .idx-min { background-color: #ffa502; color: black; }
        .idx-mid { background-color: #1e90ff; color: white; }
        .idx-p { background-color: #a55eea; color: white; }

        .comparing { background-color: #ffa502 !important; }
        .swapping { background-color: #ff4757 !important; }
        .sorted { background-color: #2ed573 !important; }
        .special { background-color: #a55eea !important; }
        .overwrite { background-color: #ff7f50 !important; }
        
        /* Màu trên cây */
        .tree-node.comparing circle { fill: #ffa502; }
        .tree-node.swapping circle { fill: #ff4757; }
        .tree-node.sorted circle { fill: #2ed573; }
        .tree-node.special circle { fill: #a55eea; }

        /* MODAL */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 1000; display: none;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #2d2d2d; padding: 30px; border-radius: 12px; text-align: center; border: 2px solid #007bff;
            box-shadow: 0 0 20px rgba(0,123,255,0.5);
        }
        .modal-btn-group {
            display: flex; gap: 15px; justify-content: center; margin-top: 20px;
        }
        .modal-btn {
            padding: 15px 25px; font-size: 16px; cursor: pointer; border: none; border-radius: 8px; color: white; transition: 0.3s;
        }
        .btn-m-bar { background-color: #17a2b8; }
        .btn-m-tree { background-color: #6610f2; }
        .btn-m-both { background-color: #fd7e14; }
        .modal-btn:hover { transform: scale(1.05); filter: brightness(1.1); }

    </style>
</head>
<body class="mode-bar"> <h1>Sort Visualizer V7.0</h1>

    <div class="control-panel">
        <div class="group">
            <input type="text" id="user-input" placeholder="VD: 5, 12, 7...">
            <button class="btn-input" onclick="generateFromInput()">Nhập</button>
            <button class="btn-input" onclick="generateRandom()">Ngẫu Nhiên</button>
        </div>

        <div class="group">
            <select id="sort-order" onchange="updateSortOrder()">
                <option value="asc">Tăng dần</option>
                <option value="desc">Giảm dần</option>
            </select>
            <div class="slider-container">
                <span>Tốc độ:</span>
                <input type="range" id="speed-slider" min="1" max="100" value="50" oninput="updateSpeed()">
            </div>
        </div>

        <div class="group">
            <button id="btn-reset" class="btn-reset" onclick="resetSystem()">RESET</button>
            <button id="btn-pause" class="btn-control" onclick="pauseAnimation()" disabled>Tạm Dừng</button>
            <button id="btn-resume" class="btn-control" onclick="resumeAnimation()" disabled>Tiếp Tục</button>
            <button id="btn-step" class="btn-step" onclick="stepAnimation()" disabled>Bước Kế</button>
        </div>

        <div class="group" style="flex-wrap: wrap; justify-content: center;">
            <button class="btn-algo" onclick="runAlgo('interchange')">Interchange</button>
            <button class="btn-algo" onclick="runAlgo('bubble')">Bubble</button>
            <button class="btn-algo" onclick="runAlgo('selection')">Selection</button>
            <button class="btn-algo" onclick="runAlgo('insertion')">Insertion</button>
            <button class="btn-algo" onclick="runAlgo('shell')">Shell</button>
            <button class="btn-algo" onclick="runAlgo('heap')">Heap</button>
            <button class="btn-algo" onclick="runAlgo('merge')">Merge</button>
            <button class="btn-algo" onclick="runAlgo('quick')">Quick</button>
        </div>
    </div>

    <div id="status-board">Sẵn sàng. Chọn thuật toán.</div>

    <div id="main-display">
        <div id="visualizer-container"></div>
        
        <div id="tree-view">
            <svg id="tree-svg">
                <defs>
                    <marker id="arrowhead-compare" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#ffa502" />
                    </marker>
                    <marker id="arrowhead-swap" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#ff4757" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div id="log-container">
        <table id="log-table">
            <thead>
                <tr>
                    <th>Bước / Giai đoạn</th>
                    <th>Trạng thái Mảng</th>
                </tr>
            </thead>
            <tbody id="log-body"></tbody>
        </table>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2>Chọn Chế Độ Hiển Thị Heap Sort</h2>
            <p>Bạn muốn xem mô phỏng dưới dạng nào?</p>
            <div class="modal-btn-group">
                <button class="modal-btn btn-m-bar" onclick="selectViewMode('bar')">Chỉ Đồ Thị</button>
                <button class="modal-btn btn-m-tree" onclick="selectViewMode('tree')">Chỉ Cây</button>
                <button class="modal-btn btn-m-both" onclick="selectViewMode('both')">Cả Hai (50/50)</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById("visualizer-container");
        const statusBoard = document.getElementById("status-board");
        const userInput = document.getElementById("user-input");
        const sortOrderSelect = document.getElementById("sort-order");
        const speedSlider = document.getElementById("speed-slider");
        const treeView = document.getElementById("tree-view");
        const treeSvg = document.getElementById("tree-svg");
        const logBody = document.getElementById("log-body");
        const modal = document.getElementById("modal-overlay");

        let bars = []; 
        let isRunning = false;
        let isPaused = false;
        let resolveStep = null;
        let abortController = null;
        let currentMax = 100;
        let isAscending = true; 
        let delayTime = 400;
        let currentAlgoName = "";
        let currentViewMode = "bar"; // bar, tree, both
        let resolveModal = null; // Promise cho modal

        /* --- SYNC & CONTROL --- */
        async function wait() {
            if (abortController && abortController.signal.aborted) return Promise.reject(new Error("ABORT"));
            
            // Vẽ lại cây nếu đang ở chế độ có Tree
            if (currentAlgoName === 'heap' && currentViewMode !== 'bar') drawHeapTree();

            if (isPaused) {
                await new Promise(resolve => resolveStep = resolve);
            } else {
                await new Promise(resolve => setTimeout(resolve, delayTime));
            }
            if (abortController && abortController.signal.aborted) return Promise.reject(new Error("ABORT"));
        }

        function updateSpeed() {
            const val = parseInt(speedSlider.value);
            delayTime = 1010 - (val * 10); 
        }

        function pauseAnimation() {
            if (!isRunning) return;
            isPaused = true;
            toggleControlButtons(true);
            statusBoard.innerText = "TẠM DỪNG";
        }

        function resumeAnimation() {
            if (!isRunning) return;
            isPaused = false;
            if (resolveStep) { resolveStep(); resolveStep = null; }
            toggleControlButtons(false);
            statusBoard.innerText = "Đang chạy...";
        }

        function stepAnimation() {
            if (!isRunning || !isPaused) return;
            if (resolveStep) { resolveStep(); resolveStep = null; }
        }

        function resetSystem() {
            if (abortController) abortController.abort();
            setTimeout(() => {
                isRunning = false;
                isPaused = false;
                resolveStep = null;
                document.body.classList.remove("running");
                
                document.querySelectorAll("button").forEach(b => b.disabled = false);
                sortOrderSelect.disabled = false;
                
                document.getElementById('btn-pause').disabled = true;
                document.getElementById('btn-resume').disabled = true;
                document.getElementById('btn-step').disabled = true;

                // Reset View Mode về Bar
                document.body.className = "mode-bar";
                currentViewMode = "bar";
                currentAlgoName = "";
                
                clearVisualStyles();
                clearLogs();
                statusBoard.innerText = "Đã Reset.";
            }, 100);
        }

        function updateSortOrder() {
            isAscending = sortOrderSelect.value === 'asc';
            statusBoard.innerText = isAscending ? "Đã chọn: Tăng dần" : "Đã chọn: Giảm dần";
        }

        /* --- MODAL LOGIC --- */
        function showViewModal() {
            return new Promise(resolve => {
                modal.style.display = "flex";
                resolveModal = resolve;
            });
        }

        function selectViewMode(mode) {
            modal.style.display = "none";
            document.body.className = `mode-${mode}`;
            currentViewMode = mode;
            if(resolveModal) resolveModal();
        }

        /* --- DOM & RENDERING --- */
        function clearVisualStyles() {
            bars.forEach(b => {
                b.bar.className = 'bar';
                b.indicatorDiv.innerHTML = '';
            });
        }

        function toggleControlButtons(paused) {
            document.getElementById('btn-pause').disabled = paused;
            document.getElementById('btn-resume').disabled = !paused;
            document.getElementById('btn-step').disabled = !paused;
        }

        function calculateHeight(value, maxVal) {
            const MAX_HEIGHT_PX = 300; 
            const MIN_HEIGHT_PX = 40; 
            if (maxVal === 0) return MIN_HEIGHT_PX;
            let percent = value / maxVal;
            let height = percent * MAX_HEIGHT_PX;
            return Math.max(height, MIN_HEIGHT_PX);
        }

        function createBarDOM(value, maxVal) {
            const wrapper = document.createElement("div");
            wrapper.classList.add("bar-wrapper");

            const label = document.createElement("div");
            label.classList.add("bar-val");
            label.innerText = value;

            const bar = document.createElement("div");
            bar.classList.add("bar");
            const h = calculateHeight(value, maxVal);
            bar.style.height = `${h}px`;

            const delBtn = document.createElement("div");
            delBtn.classList.add("delete-icon");
            delBtn.innerHTML = "&times;";
            delBtn.onclick = () => deleteBar(wrapper);

            const indicatorDiv = document.createElement("div");
            indicatorDiv.classList.add("indicator-container");

            wrapper.appendChild(label);
            wrapper.appendChild(bar);
            wrapper.appendChild(delBtn);
            wrapper.appendChild(indicatorDiv);
            container.appendChild(wrapper);

            const barObj = { wrapper, bar, label, value, indicatorDiv };
            bars.push(barObj);
            return barObj;
        }

        function deleteBar(wrapperDOM) {
            if (isRunning) return;
            const idx = bars.findIndex(b => b.wrapper === wrapperDOM);
            if (idx !== -1) {
                bars.splice(idx, 1);
                wrapperDOM.remove();
            }
        }

        /* --- LOG TABLE --- */
        function clearLogs() {
            logBody.innerHTML = "";
        }

        function addLog(stepName) {
            const tr = document.createElement("tr");
            const tdStep = document.createElement("td");
            tdStep.classList.add("log-step");
            tdStep.innerText = stepName;
            const tdArray = document.createElement("td");
            tdArray.classList.add("log-array");
            const currentValues = bars.map(b => b.value).join(", ");
            tdArray.innerText = `[ ${currentValues} ]`;
            tr.appendChild(tdStep);
            tr.appendChild(tdArray);
            logBody.appendChild(tr);
            document.getElementById("log-container").scrollTop = document.getElementById("log-container").scrollHeight;
        }

        /* --- TREE VISUALIZATION (ENHANCED) --- */
        // Biến lưu trữ các mũi tên cần vẽ trên cây
        let treeArrows = []; 

        function drawHeapTree() {
            // Giữ lại defs (markers)
            const defs = treeSvg.querySelector('defs').outerHTML;
            treeSvg.innerHTML = defs;
            
            if (bars.length === 0) return;

            const canvasWidth = treeView.clientWidth || 600;
            // Tính toán tọa độ
            bars.forEach((barObj, index) => {
                const depth = Math.floor(Math.log2(index + 1));
                const posInLevel = index - Math.pow(2, depth) + 1;
                // Chuẩn hóa vị trí X cho cây nhị phân cân bằng
                // Chia chiều rộng thành 2^(depth+1) phần
                const slots = Math.pow(2, depth + 1);
                const section = canvasWidth / slots;
                const realX = section * (2 * posInLevel + 1);
                const realY = depth * 70 + 40;

                barObj.treeX = realX;
                barObj.treeY = realY;

                // Vẽ đường nối
                if (index > 0) {
                    const parentIdx = Math.floor((index - 1) / 2);
                    const parent = bars[parentIdx];
                    if (parent) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", parent.treeX);
                        line.setAttribute("y1", parent.treeY);
                        line.setAttribute("x2", realX);
                        line.setAttribute("y2", realY);
                        line.setAttribute("class", "tree-line");
                        treeSvg.appendChild(line);
                    }
                }
            });

            // Vẽ Nodes
            bars.forEach((barObj, index) => {
                const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
                group.setAttribute("class", "tree-node");
                if (barObj.bar.classList.contains("comparing")) group.classList.add("comparing");
                if (barObj.bar.classList.contains("swapping")) group.classList.add("swapping");
                if (barObj.bar.classList.contains("sorted")) group.classList.add("sorted");
                if (barObj.bar.classList.contains("special")) group.classList.add("special");

                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", barObj.treeX);
                circle.setAttribute("cy", barObj.treeY);
                circle.setAttribute("r", 20);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", barObj.treeX);
                text.setAttribute("y", barObj.treeY);
                text.textContent = barObj.value;

                group.appendChild(circle);
                group.appendChild(text);
                treeSvg.appendChild(group);
            });

            // Vẽ mũi tên chỉ dẫn (nếu có)
            treeArrows.forEach(arrow => {
                const node1 = bars[arrow.from];
                const node2 = bars[arrow.to];
                if(node1 && node2) {
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    
                    // Vẽ đường cong Bezier giữa 2 node
                    const d = `M ${node1.treeX} ${node1.treeY} Q ${(node1.treeX + node2.treeX)/2 + 30} ${(node1.treeY + node2.treeY)/2} ${node2.treeX} ${node2.treeY}`;
                    
                    path.setAttribute("d", d);
                    path.setAttribute("class", arrow.type === 'swap' ? 'tree-arrow-swap' : 'tree-arrow-compare');
                    treeSvg.appendChild(path);
                }
            });
        }

        /* --- DATA GENERATION --- */
        function generateRandom() {
            resetSystem();
            setTimeout(() => {
                container.innerHTML = "";
                bars = [];
                let arr = [];
                for (let i = 0; i < 15; i++) arr.push(Math.floor(Math.random() * 90) + 10);
                currentMax = Math.max(...arr);
                arr.forEach(val => createBarDOM(val, currentMax));
                statusBoard.innerText = "Đã tạo mảng ngẫu nhiên";
                addLog("Khởi tạo ngẫu nhiên");
            }, 150);
        }

        function generateFromInput() {
            resetSystem();
            setTimeout(() => {
                const val = userInput.value;
                const arr = val.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
                if (arr.length > 0) {
                    container.innerHTML = "";
                    bars = [];
                    currentMax = Math.max(...arr);
                    if (currentMax === 0) currentMax = 1;
                    arr.forEach(x => createBarDOM(x, currentMax));
                    statusBoard.innerText = "Đã nhập dữ liệu";
                    addLog("Khởi tạo từ Input");
                } else {
                    alert("Lỗi nhập liệu!");
                }
            }, 150);
        }

        /* --- HELPER VISUALS --- */
        function drawIndicators(assignments) {
            bars.forEach(b => b.indicatorDiv.innerHTML = '');
            for (const [key, index] of Object.entries(assignments)) {
                if (index >= 0 && index < bars.length) {
                    const badge = document.createElement("div");
                    badge.classList.add("arrow-label");
                    badge.innerText = key;
                    if (key === 'i') badge.classList.add('idx-i');
                    else if (key === 'j') badge.classList.add('idx-j');
                    else if (key.includes('min') || key.includes('max')) badge.classList.add('idx-min');
                    else if (key.includes('mid') || key.includes('left') || key.includes('right')) badge.classList.add('idx-mid');
                    else if (key === 'pivot') badge.classList.add('idx-p');
                    else badge.style.backgroundColor = '#666';
                    bars[index].indicatorDiv.appendChild(badge);
                }
            }
        }

        // Cập nhật hàm Swap để thêm mũi tên trên cây
        async function swapVisual(i, j) {
            bars[i].bar.classList.add("swapping");
            bars[j].bar.classList.add("swapping");
            
            // Thêm mũi tên SWAP vào cây
            treeArrows = [{from: i, to: j, type: 'swap'}];
            
            await wait();

            let tmp = bars[i].value;
            bars[i].value = bars[j].value;
            bars[j].value = tmp;
            
            bars[i].label.innerText = bars[i].value;
            bars[j].label.innerText = bars[j].value;
            
            let h1 = bars[i].bar.style.height;
            let h2 = bars[j].bar.style.height;
            bars[i].bar.style.height = h2;
            bars[j].bar.style.height = h1;

            await wait();
            
            bars[i].bar.classList.remove("swapping");
            bars[j].bar.classList.remove("swapping");
            treeArrows = []; // Xóa mũi tên
        }

        async function overwriteVisual(idx, val) {
            bars[idx].bar.classList.add("overwrite");
            await wait();
            bars[idx].value = val;
            bars[idx].label.innerText = val;
            const h = calculateHeight(val, currentMax);
            bars[idx].bar.style.height = `${h}px`;
            await wait();
            bars[idx].bar.classList.remove("overwrite");
        }

        function shouldSwap(a, b) {
            return isAscending ? (a > b) : (a < b);
        }

        // Helper để set mũi tên so sánh trên cây
        function setTreeCompare(i, j) {
            treeArrows = [{from: i, to: j, type: 'compare'}];
        }
        function clearTreeArrows() {
            treeArrows = [];
        }

        /* ================= ALGORITHMS ================= */

        async function runAlgo(name) {
            if (bars.length === 0) { alert("Mảng trống!"); return; }
            if (isRunning) return;

            // Nếu là Heap, hỏi View Mode trước
            if (name === 'heap') {
                await showViewModal();
                // Sau khi modal đóng, biến currentViewMode đã được set
            } else {
                // Các thuật toán khác mặc định chỉ hiện Bar
                document.body.className = "mode-bar";
                currentViewMode = "bar";
            }

            isRunning = true;
            isPaused = false;
            document.body.classList.add("running");
            abortController = new AbortController();
            currentAlgoName = name;
            clearLogs(); 
            addLog("Bắt đầu " + name.toUpperCase());

            document.querySelectorAll('.btn-algo').forEach(b => b.disabled = true);
            sortOrderSelect.disabled = true;
            document.getElementById('btn-reset').disabled = false;
            document.getElementById('btn-pause').disabled = false;
            document.getElementById('btn-resume').disabled = true;
            document.getElementById('btn-step').disabled = true;

            try {
                if (name === 'interchange') await interchangeSort();
                if (name === 'bubble') await bubbleSort();
                if (name === 'selection') await selectionSort();
                if (name === 'insertion') await insertionSort();
                if (name === 'shell') await shellSort();
                if (name === 'heap') await heapSort();
                if (name === 'merge') await startMergeSort();
                if (name === 'quick') await startQuickSort();

                statusBoard.innerText = "HOÀN TẤT!";
                addLog("Hoàn thành thuật toán");
                clearVisualStyles();
                bars.forEach(b => b.bar.classList.add("sorted"));
                treeArrows = []; // Xóa mũi tên cuối cùng
                if (name === 'heap' && currentViewMode !== 'bar') drawHeapTree();

            } catch (err) {
                if (err.message !== "ABORT") console.error(err);
            } finally {
                if (isRunning) {
                    isRunning = false;
                    document.body.classList.remove("running");
                    document.querySelectorAll('.btn-algo').forEach(b => b.disabled = false);
                    sortOrderSelect.disabled = false;
                    document.getElementById('btn-pause').disabled = true;
                    document.getElementById('btn-step').disabled = true;
                    drawIndicators({});
                }
            }
        }

        /* --- ALGORITHM IMPLEMENTATIONS --- */
        
        async function interchangeSort() {
            let n = bars.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = i + 1; j < n; j++) {
                    drawIndicators({ i, j });
                    bars[i].bar.classList.add("comparing");
                    bars[j].bar.classList.add("comparing");
                    await wait();
                    if (shouldSwap(bars[i].value, bars[j].value)) {
                        await swapVisual(i, j);
                    }
                    bars[i].bar.classList.remove("comparing");
                    bars[j].bar.classList.remove("comparing");
                }
                bars[i].bar.classList.add("sorted");
                addLog(`Duyệt xong vị trí ${i}`);
            }
            bars[n-1].bar.classList.add("sorted");
        }

        async function bubbleSort() {
            let n = bars.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    drawIndicators({ i, j: j, next: j+1 });
                    bars[j].bar.classList.add("comparing");
                    bars[j+1].bar.classList.add("comparing");
                    await wait();
                    if (shouldSwap(bars[j].value, bars[j + 1].value)) {
                        await swapVisual(j, j + 1);
                    }
                    bars[j].bar.classList.remove("comparing");
                    bars[j+1].bar.classList.remove("comparing");
                }
                bars[n - 1 - i].bar.classList.add("sorted");
                addLog(`Nổi bọt phần tử ${n-1-i} về cuối`);
            }
            bars[0].bar.classList.add("sorted");
        }

        async function selectionSort() {
            let n = bars.length;
            for (let i = 0; i < n; i++) {
                let bestIdx = i;
                bars[i].bar.classList.add("special");
                for (let j = i + 1; j < n; j++) {
                    drawIndicators({ i, j, [isAscending ? 'min' : 'max']: bestIdx });
                    bars[j].bar.classList.add("comparing");
                    await wait();
                    let condition = isAscending ? (bars[j].value < bars[bestIdx].value) : (bars[j].value > bars[bestIdx].value);
                    if (condition) {
                        if (bestIdx !== i) bars[bestIdx].bar.classList.remove("swapping");
                        bestIdx = j;
                        bars[bestIdx].bar.classList.add("swapping");
                    }
                    bars[j].bar.classList.remove("comparing");
                }
                if (bestIdx !== i) await swapVisual(i, bestIdx);
                bars[bestIdx].bar.classList.remove("swapping");
                bars[i].bar.classList.remove("special");
                bars[i].bar.classList.add("sorted");
                addLog(`Tìm được ${isAscending ? 'Min' : 'Max'} cho vị trí ${i}`);
            }
        }

        async function insertionSort() {
            bars[0].bar.classList.add("sorted");
            for (let i = 1; i < bars.length; i++) {
                let j = i;
                while (j > 0) {
                    drawIndicators({ i, j, prev: j-1 });
                    bars[j].bar.classList.add("comparing");
                    bars[j-1].bar.classList.add("comparing");
                    await wait();
                    let condition = isAscending ? (bars[j].value < bars[j - 1].value) : (bars[j].value > bars[j - 1].value);
                    if (condition) {
                        await swapVisual(j, j - 1);
                        bars[j].bar.classList.remove("comparing");
                        bars[j].bar.classList.remove("sorted");
                        bars[j-1].bar.classList.remove("comparing");
                        j--;
                    } else {
                        bars[j].bar.classList.remove("comparing");
                        bars[j-1].bar.classList.remove("comparing");
                        break;
                    }
                }
                for(let k=0; k<=i; k++) bars[k].bar.classList.add("sorted");
                addLog(`Chèn phần tử thứ ${i} vào đoạn`);
            }
        }

        async function shellSort() {
            let n = bars.length;
            for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                addLog(`Sắp xếp với Gap = ${gap}`);
                for (let i = gap; i < n; i++) {
                    let temp = bars[i].value;
                    let j;
                    bars[i].bar.classList.add("special");
                    for (j = i; j >= gap; j -= gap) {
                        drawIndicators({ i, j, cmp: j-gap });
                        bars[j].bar.classList.add("comparing");
                        bars[j-gap].bar.classList.add("comparing");
                        await wait();
                        let condition = isAscending ? (bars[j-gap].value > temp) : (bars[j-gap].value < temp);
                        if (condition) {
                            await overwriteVisual(j, bars[j-gap].value);
                            bars[j].bar.classList.remove("comparing");
                            bars[j-gap].bar.classList.remove("comparing");
                        } else {
                            bars[j].bar.classList.remove("comparing");
                            bars[j-gap].bar.classList.remove("comparing");
                            break;
                        }
                    }
                    await overwriteVisual(j, temp);
                    bars[i].bar.classList.remove("special");
                }
            }
        }

        async function heapSort() {
            let n = bars.length;
            statusBoard.innerText = `Heap: Build ${isAscending ? 'Max' : 'Min'} Heap`;
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
            addLog(`Đã xây dựng xong Heap`);
            
            statusBoard.innerText = `Heap: Extract ${isAscending ? 'Max' : 'Min'}`;
            for (let i = n - 1; i > 0; i--) {
                drawIndicators({ [isAscending?'max':'min']: 0, end: i });
                await swapVisual(0, i);
                bars[i].bar.classList.add("sorted");
                addLog(`Đưa phần tử gốc về vị trí ${i}`);
                await heapify(i, 0);
            }
            bars[0].bar.classList.add("sorted");
        }

        async function heapify(n, i) {
            let target = i;
            let left = 2 * i + 1;
            let right = 2 * i + 2;
            drawIndicators({ root: i, L: left<n?left:-1, R: right<n?right:-1 });
            bars[i].bar.classList.add("special");
            
            // Vẽ mũi tên so sánh trên cây nếu tồn tại con
            if (left < n) setTreeCompare(i, left);
            
            await wait();
            
            if (isAscending) {
                if (left < n && bars[left].value > bars[target].value) target = left;
                if (right < n && bars[right].value > bars[target].value) target = right;
            } else {
                if (left < n && bars[left].value < bars[target].value) target = left;
                if (right < n && bars[right].value < bars[target].value) target = right;
            }

            clearTreeArrows(); // Xóa mũi tên so sánh

            if (target != i) {
                drawIndicators({ swap: target });
                await swapVisual(i, target);
                bars[i].bar.classList.remove("special");
                await heapify(n, target);
            } else bars[i].bar.classList.remove("special");
        }

        async function startMergeSort() {
            await mergeSortRecursive(0, bars.length - 1);
        }

        async function mergeSortRecursive(l, r) {
            if (l >= r) return;
            const m = l + Math.floor((r - l) / 2);
            await mergeSortRecursive(l, m);
            await mergeSortRecursive(m + 1, r);
            await merge(l, m, r);
            addLog(`Merge đoạn [${l}..${m}] và [${m+1}..${r}]`);
        }

        async function merge(l, m, r) {
            for(let k=l; k<=r; k++) bars[k].bar.classList.add("comparing");
            let n1 = m - l + 1, n2 = r - m;
            let L = [], R = [];
            for (let i = 0; i < n1; i++) L.push(bars[l + i].value);
            for (let j = 0; j < n2; j++) R.push(bars[m + 1 + j].value);
            let i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                drawIndicators({ left: l+i, right: m+1+j, target: k });
                await wait();
                let takeLeft = isAscending ? (L[i] <= R[j]) : (L[i] >= R[j]);
                if (takeLeft) { await overwriteVisual(k, L[i]); i++; }
                else { await overwriteVisual(k, R[j]); j++; }
                k++;
            }
            while (i < n1) { drawIndicators({ left: l+i, target: k }); await overwriteVisual(k, L[i]); i++; k++; }
            while (j < n2) { drawIndicators({ right: m+1+j, target: k }); await overwriteVisual(k, R[j]); j++; k++; }
            for(let k=l; k<=r; k++) bars[k].bar.classList.remove("comparing");
        }

        async function startQuickSort() {
            await quickSort(0, bars.length - 1);
        }

        async function quickSort(low, high) {
            if (low < high) {
                let pi = await partition(low, high);
                bars[pi].bar.classList.add("sorted");
                addLog(`Phân hoạch xong, Pivot tại ${pi}`);
                await quickSort(low, pi - 1);
                await quickSort(pi + 1, high);
            } else if (low === high) bars[low].bar.classList.add("sorted");
        }

        async function partition(low, high) {
            let pivot = bars[high].value;
            bars[high].bar.classList.add("special");
            let i = (low - 1);
            for (let j = low; j <= high - 1; j++) {
                drawIndicators({ i, j, pivot: high });
                bars[j].bar.classList.add("comparing");
                await wait();
                let condition = isAscending ? (bars[j].value < pivot) : (bars[j].value > pivot);
                if (condition) {
                    i++;
                    await swapVisual(i, j);
                }
                bars[j].bar.classList.remove("comparing");
            }
            await swapVisual(i + 1, high);
            bars[high].bar.classList.remove("special");
            return (i + 1);
        }

        generateRandom();

    </script>
</body>
</html>